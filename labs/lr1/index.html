<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Lab №1 - UpaffyWeb</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/color-brewer.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">UpaffyWeb</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Lab №1</a>
                            </li>
                            <li class="navitem">
                                <a href="../lr2/" class="nav-link">Lab №2</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../.." class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../lr2/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#tasks-1-3" class="nav-link">Tasks 1-3</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#task-1" class="nav-link">Task 1</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#task-2" class="nav-link">Task 2</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#task-3" class="nav-link">Task 3</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#task-4" class="nav-link">Task 4</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#task-5" class="nav-link">Task 5</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="tasks-1-3">Tasks 1-3</h1>
<p>Для задач с 1 по 3 включительно отдельно вынесены два класса, реализующие серверную и клиентскую части:</p>
<p><em>server.py</em></p>
<pre><code class="language-python">import socket


class Server:
    def __init__(self, protocol_type: str):
        if protocol_type == &quot;UDP&quot;:
            self.socket = self.__create_UDP_socket()
        elif protocol_type == &quot;TCP&quot;:
            self.socket = self.__create_TCP_socket()

    def __create_TCP_socket(self) -&gt; socket:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind((socket.gethostname(), 1234))
        sock.listen(1)

        return sock

    def __create_UDP_socket(self):
        sock = socket.socket()
        sock.bind((socket.gethostname(), 1234))
        sock.listen(1)

        return sock

    def send_data_to_client(self, client_socket: socket.socket, data: str):
        client_socket.send(data.encode())

    def get_data_from_client(self, client_socket: socket.socket) -&gt; str:
        encoded_data = client_socket.recv(1024)
        data = encoded_data.decode(&quot;utf-8&quot;)

        return data

    def accept_connection(self) -&gt; (socket, tp.Any):
        return self.socket.accept()
</code></pre>
<p><em>client.py</em></p>
<pre><code class="language-python">import socket


class Client:
    def __init__(self, protocol_type: str):
        if protocol_type == &quot;UDP&quot;:
            self.socket = self.__create_UDP_socket()
        elif protocol_type == &quot;TCP&quot;:
            self.socket = self.__create_TCP_socket()

    def __create_TCP_socket(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((socket.gethostname(), 1234))

        return sock

    def __create_UDP_socket(self):
        sock = socket.socket()
        sock.connect((socket.gethostname(), 1234))

        return sock

    def send_data_to_server(self, data: str):
        self.socket.send(data.encode())

    def get_data_from_server(self) -&gt; str:
        encoded_data = self.socket.recv(1024)
        data = encoded_data.decode(&quot;utf-8&quot;)

        return data
</code></pre>
<hr />
<h2 id="task-1">Task 1</h2>
<h4 id="_1">Задание</h4>
<p>Реализовать клиентскую и серверную часть приложения, используя проотокол UDP.
Клиент отсылает серверу сообщение «Hello, server». Сообщение должно отразиться на стороне сервера.
Сервер в ответ отсылает клиенту сообщение «Hello, client». Сообщение должно
отобразиться у клиента.</p>
<h4 id="_2">Реализация</h4>
<p><em>server.py</em></p>
<pre><code class="language-python">from Lr1.server import Server


class FirstTaskServer(Server):
    def start(self):
        # create connection
        client_socket, address = self.accept_connection()
        self.send_data_to_client(client_socket, &quot;Hello, client&quot;)

        client_data = self.get_data_from_client(client_socket)
        print(client_data)

        client_socket.close()
        self.socket.close()
</code></pre>
<p><em>client.py</em></p>
<pre><code class="language-python">from Lr1.client import Client


class FirstTaskClient(Client):
    def start(self):
        self.send_data_to_server(&quot;Hello, server!&quot;)

        server_data = self.get_data_from_server()
        print(server_data)

        self.socket.close()
</code></pre>
<h4 id="_3">Запуск</h4>
<pre><code class="language-python">server = FirstTaskServer(&quot;UDP&quot;)
server.start()

client = FirstTaskClient(&quot;UDP&quot;)
client.start()
</code></pre>
<hr />
<h2 id="task-2">Task 2</h2>
<h4 id="_4">Задание</h4>
<p>Реализовать клиентскую и серверную часть приложения с помощью протокола TCP. 
Клиент запрашивает у сервера расчет площади параллелограмма, задавая с клавиатуры координаты двух векторов на которых он построен в трехмерной системе координат. 
Сервер обрабатывает полученные данные и возвращает результат
клиенту.</p>
<h4 id="_5">Реализация</h4>
<p><em>server.py</em></p>
<pre><code class="language-python">from Lr1.server import Server
import typing as tp


class SecondTaskServer(Server):
    def start(self):
        client_socket, address = self.accept_connection()

        while not self.area:
            while len(self.vectors) &lt; 2:
                if len(self.vectors) == 0:
                    self.send_data_to_client(client_socket, &quot;First vector&quot;)
                else:
                    self.send_data_to_client(client_socket, &quot;Second vector&quot;)

                data = self.get_data_from_client(client_socket)
                self._set_vector_from_data(data)

            self._set_area()
            client_socket.send(str(self.area).encode())

        client_socket.close()
        self.socket.close()

    def _set_vector_from_data(self, data: str):
        coords = tuple(map(float, data.split()))
        self.vectors.append(coords)

    def _set_area(self):
        x = self.vectors[0][1] * self.vectors[1][2] - self.vectors[0][2] * self.vectors[1][1]
        y = self.vectors[0][0] * self.vectors[1][2] - self.vectors[0][2] * self.vectors[1][0]
        z = self.vectors[0][0] * self.vectors[1][1] - self.vectors[0][1] * self.vectors[1][0]

        self.area = (x**2 + y**2 + z**2)**0.5

    def __init__(self, protocol_type: str):
        super().__init__(protocol_type)
        self.vectors: tp.List[tp.Tuple[float, ...]] = []
        self.area = 0.0
</code></pre>
<p><em>client.py</em></p>
<pre><code class="language-python">from Lr1.client import Client


class SecondTaskClient(Client):
    def start(self):
        first_vector = input(&quot;Enter first vector's coordinates x, y, z: &quot;)
        second_vector = input(&quot;Enter second vector's coordinates x, y, z: &quot;)

        while True:
            data = self.get_data_from_server()
            if data == &quot;First vector&quot;:
                self.send_data_to_server(first_vector)
            elif data == &quot;Second vector&quot;:
                self.send_data_to_server(second_vector)
            else:
                print(data)
                break

        self.socket.close()
</code></pre>
<h4 id="_6">Запуск</h4>
<pre><code class="language-python">server = SecondTaskServer(&quot;TCP&quot;)
server.start()

client = SecondTaskClient(&quot;TCP&quot;)
client.start()
</code></pre>
<hr />
<h2 id="task-3">Task 3</h2>
<h4 id="_7">Задание</h4>
<p>Реализовать серверную часть приложения. Клиент подключается к серверу. В ответ
клиент получает http-сообщение, содержащее html-страницу, которую сервер
подгружает из файла index.html.</p>
<h4 id="_8">Реализация</h4>
<p><em>server.py</em></p>
<pre><code class="language-python">class ThirdTaskServer(Server):
    def start(self):
        client_socket, address = self.accept_connection()

        self._get_content()
        self._send_page_to_client(client_socket)

        client_socket.close()
        self.socket.close()

    def _get_content(self):
        with open(&quot;index.html&quot;, &quot;r&quot;) as file:
            self.content = file.read()

    def _send_page_to_client(self, client_socket):
        page_info = f'HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\n\r\n{self.content}'
        self.send_data_to_client(client_socket, page_info)

    def __init__(self, protocol_type: str):
        super().__init__(protocol_type)
        self.content = &quot;&quot;
</code></pre>
<h4 id="_9">Запуск</h4>
<pre><code class="language-python">server = ThirdTaskServer(&quot;TCP&quot;)
server.start()
</code></pre>
<hr />
<h1 id="task-4">Task 4</h1>
<h4 id="_10">Задание</h4>
<p>Реализовать многопользовательский чат.</p>
<h4 id="_11">Реализация</h4>
<p><em>server.py</em></p>
<pre><code class="language-python">import socket
import threading
import typing as tp


class User:
    def __init__(self, name: str, sock: socket.socket):
        self.name = name
        self.sock = sock


class ChatServer:
    def __init__(self):
        self.alive = True
        self.sock = self.__create_tcp_socket()
        self.users: tp.List[User] = []

    def __create_tcp_socket(self) -&gt; socket.socket:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind((socket.gethostname(), 1234))
        sock.listen()

        return sock

    def __send_data_to_user(self, user_socket: socket.socket, data: str):
        try:
            user_socket.send(data.encode())
        except:
            pass

    def __get_data_from_user(self, user_socket: socket.socket) -&gt; str:
        data = &quot;&quot;
        try:
            data = user_socket.recv(1024).decode()
        finally:
            return data

    def __remove_user_from_chat(self, user: User):
        user.sock.close()
        self.users.remove(user)
        self.send_broadcast_message(None, f'{user.name} has left the chat')

    def switch_off(self):
        self.alive = False
        for user in self.users:
            self.__send_data_to_user(user.sock, &quot;!END&quot;)
            user.sock.close()
        self.sock.close()

    def send_broadcast_message(self, author: tp.Optional[str], text: str):
        if author is None:
            data = f&quot;{text}&quot;
        else:
            data = f&quot;{author}: {text}&quot;

        for user in self.users:
            self.__send_data_to_user(user.sock, data)

    def handle_connection(self, user: User):
        try:
            while self.alive:
                message = self.__get_data_from_user(user.sock)
                if message != &quot;!QUIT&quot;:
                    self.send_broadcast_message(user.name, message)
                else:
                    break
        finally:
            self.__remove_user_from_chat(user)

    def serve_forever(self):
        while self.alive:
            user_socket, _ = self.sock.accept()

            self.__send_data_to_user(user_socket, &quot;Enter Username&quot;)
            username = self.__get_data_from_user(user_socket)

            user = User(username, user_socket)
            self.users.append(user)
            self.send_broadcast_message(None, f&quot;{username} has connected to the chat&quot;)

            thread = threading.Thread(target=self.handle_connection, args=(user,))
            thread.start()

    def start(self):
        try:
            self.serve_forever()
        except KeyboardInterrupt:
            self.switch_off()
</code></pre>
<p><em>client.py</em></p>
<pre><code class="language-python">import threading


class ChatClient:
    def __init__(self):
        self.username = &quot;&quot;
        self.alive = True
        self.sock = self.__create_tcp_socket()

    def __create_tcp_socket(self) -&gt; socket.socket:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((socket.gethostname(), 1234))

        return sock

    def __send_data_to_server(self, data: str):
        if self.alive:
            self.sock.send(data.encode())

    def __get_data_from_server(self) -&gt; str:
        return self.sock.recv(1024).decode()

    def __left_from_server(self):
        self.alive = False
        self.sock.close()

        print(&quot;You have left the chat&quot;)

    def receive(self):
        try:
            while self.alive:
                message = self.__get_data_from_server()
                if message == &quot;Enter Username&quot;:
                    self.__send_data_to_server(self.username)
                elif message == &quot;!END&quot;:
                    print(&quot;The server was interrupted&quot;)
                    break
                else:
                    print(message)
        finally:
            self.__left_from_server()

    def send(self):
        while self.alive:
            message = input()
            self.__send_data_to_server(message)

            if message == &quot;!QUIT&quot;:
                self.alive = False

    def start(self):
        self.username = input(&quot;Enter username: &quot;)

        get_thread = threading.Thread(target=self.receive)
        get_thread.start()

        send_thread = threading.Thread(target=self.send)
        send_thread.start()
</code></pre>
<h4 id="_12">Запуск</h4>
<pre><code class="language-python"># запустить сервер
ChatServer().start()

# создать пользователя
ChatClient().start()
</code></pre>
<hr />
<h1 id="task-5">Task 5</h1>
<h4 id="_13">Задание</h4>
<p>Необходимо написать простой web-сервер для обработки GET и POST http
запросов средствами Python и библиотеки socket. Сервер должен уметь:
- Принять и записать информацию о дисциплине и оценке по дисциплине.
- Отдать информацию обо всех оценах по дсициплине в виде html-страницы.</p>
<h4 id="_14">Реализация</h4>
<p><em>request.py</em></p>
<pre><code class="language-python">import typing as tp
from urllib.parse import parse_qs, urlparse


class Request:
    def __init__(
            self,
            method: str,
            target: str,
            version: str,
            headers: tp.Dict[str, tp.Any]
    ):
        self.method = method
        self.target = target
        self.version = version
        self.headers = headers

    @property
    def path(self):
        return self._url.path

    @property
    def query(self):
        return parse_qs(self._url.query)

    @property
    def _url(self):
        return urlparse(self.target)
</code></pre>
<p><em>response.py</em></p>
<pre><code class="language-python">import typing as tp


class Response:
    def __init__(
            self,
            status: int,
            reason: str,
            headers: tp.Optional[tp.Dict[str, tp.Any]] = None,
            body: tp.Optional[bytes] = None
    ):
        self.status = status
        self.reason = reason
        self.headers = headers
        self.body = body
</code></pre>
<p><em>server.py</em></p>
<pre><code class="language-python">import email.message
import socket
import typing as tp
import json

from Lr1.task5.request import Request
from Lr1.task5.response import Response
from email.parser import Parser

MAX_LINE = 64 * 1024
MAX_HEADERS = 100


class HTTPError(Exception):
    def __init__(self, status, reason, body=None):
        super()
        self.status = status
        self.reason = reason
        self.body = body


class HTTPServer:
    def __init__(self, host: str, port: int):
        self.server: tp.Optional[socket.socket] = self.__create_tcp_socket(host, port)
        self._grades: tp.Dict[str, int] = {}

    def __create_tcp_socket(self, host: str, port: int) -&gt; tp.Optional[socket.socket]:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.bind((host, port))
            sock.listen()
            return sock
        except socket.error:
            sock.close()
            return None

    def __map_message_to_dict(self, message: email.message.Message) -&gt; tp.Dict[str, tp.Any]:
        res_dict = {}
        for key in message.keys():
            res_dict[key] = message[key]

        return res_dict

    def __handle_post_grades(self, req: Request) -&gt; Response:
        try:
            subject = req.query['subject'][0]
            grade = req.query['grade'][0]
            self._grades[subject] = int(grade)
        except Exception:
            raise HTTPError(400, &quot;Bad Request&quot;)

        return Response(204, 'Created')

    def __handle_get_grades(self, req: Request) -&gt; Response:
        accept = req.headers.get('Accept')

        if accept is None:
            raise HTTPError(400, &quot;Bad Request&quot;)

        if 'application/json' in accept:
            content_type = 'application/json; charset=utf-8'
            body = json.dumps(self._grades)
        else:
            return Response(406, 'Not Acceptable')

        headers = {'Content-Type': content_type,
                   'Content-Length': len(body)}

        return Response(200, 'OK', headers, body.encode('utf-8'))

    def serve_forever(self):
        if self.server is None:
            return

        try:
            while True:
                conn, _ = self.server.accept()
                try:
                    self.serve_client(conn)
                except Exception as e:
                    print('Client serving failed', e)
        except KeyboardInterrupt:
            self.server.close()

    def serve_client(self, conn: socket.socket):
        try:
            req = self.parse_request(conn)
            resp = self.handle_request(req)
            self.send_response(conn, resp)
        except ConnectionResetError:
            conn = None
        except HTTPError as e:
            self.send_error(conn, e)

        if conn:
            conn.close()

    def parse_request(self, conn) -&gt; Request:
        rfile = conn.makefile('rb')

        method, target, ver = self.parse_request_line(rfile)
        headers = self.parse_headers(rfile)

        return Request(method, target, ver, headers)

    def parse_headers(self, rfile) -&gt; tp.Dict[str, tp.Any]:
        headers = []
        while True:
            line = rfile.readline(MAX_LINE + 1)
            if len(line) &gt; MAX_LINE:
                raise HTTPError(494, 'Request header too large')

            if line in (b'\r\n', b'\n', b''):
                break

            headers.append(line)
            if len(headers) &gt; MAX_HEADERS:
                raise HTTPError(494, 'Too many headers')

        sheaders = b''.join(headers).decode('iso-8859-1')
        message = Parser().parsestr(sheaders)

        return self.__map_message_to_dict(message)

    def parse_request_line(self, rfile) -&gt; tp.Tuple[str, ...]:
        raw = rfile.readline(MAX_LINE + 1)
        if len(raw) &gt; MAX_LINE:
            raise HTTPError(400, 'Bad request', 'Request line is too long')

        req_line = str(raw, 'iso-8859-1')
        req_line = req_line.rstrip('\r\n')
        words = req_line.split()

        if len(words) != 3:
            raise HTTPError(400, 'Bad request', 'Malformed request line')

        method, target, ver = words
        if ver != 'HTTP/1.1':
            raise HTTPError(505, 'HTTP Version Not Supported')

        return method, target, ver

    def handle_request(self, req: Request) -&gt; Response:
        if req.path == '/api' and req.method == 'POST':
            return self.__handle_post_grades(req)

        if req.path == '/api' and req.method == 'GET':
            return self.__handle_get_grades(req)

        raise HTTPError(404, 'Not found')

    def send_response(self, conn: socket.socket, resp: Response):
        wfile = conn.makefile('wb')
        status_line = f'HTTP/1.1 {resp.status} {resp.reason}\r\n'
        wfile.write(status_line.encode('iso-8859-1'))

        if resp.headers:
            for (key, value) in resp.headers.items():
                header_line = f'{key}: {value}\r\n'
                wfile.write(header_line.encode('iso-8859-1'))

        wfile.write(b'\r\n')

        if resp.body:
            wfile.write(resp.body)

        wfile.flush()
        wfile.close()

    def send_error(self, conn: socket.socket, err: HTTPError):
        try:
            status = err.status
            reason = err.reason
            body = (err.body or err.reason).encode('utf-8')
        except Exception:
            status = 500
            reason = b'Internal Server Error'
            body = b'Internal Server Error'

        resp = Response(
            status,
            reason,
            {'Content-Length': len(body)},
            body
        )

        self.send_response(conn, resp)
</code></pre>
<h4 id="_15">Запуск</h4>
<pre><code class="language-python">host = &quot;127.0.0.1&quot;
port = 1234
serv = HTTPServer(host, port)

serv.serve_forever()
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
